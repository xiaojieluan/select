function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}
 
var f1 = Foo(),
    f2 = Foo();
f1();
f1();
f2();

/*
考点：闭包和引用类型对象
一般来说函数执行完后它的局部变量就会随着函数调用结束被销毁，但是此题foo函数返回了一个匿名函数的引用（即一个闭包），
它可以访问到foo()被调用产生的环境，而局部变量i一直处在这个环境中，只要一个环境有可能被访问到，它就不会被销毁，所以
说闭包有延续变量作用域的功能。

Foo()返回的是一个匿名函数，f1,f2相当于指向了两个不同的函数对象
所以两个函数中虽然变量名是一样的，但是不是同一个变量



*/